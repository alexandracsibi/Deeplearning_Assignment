# -*- coding: utf-8 -*-
"""data_module.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ULFCdhBgLb3WP-Xnx80CVQmzGk0jimMU
"""

import torch
import torch_geometric as tg
import pandas as pd
import numpy as np
import pytorch_lightning as pl

class GDADataset(tg.data.Dataset):
  def __init__(self, root, transform=None, pre_transform=None):
    super(GDADataset, self).__init__(root, transform, pre_transform)

  @property
  def raw_file_names(self):
    return ['GDA_df_processed.csv']

  @property
  def processed_file_names(self):
    return ['data.pt']

  def download(self):
    # Add download logic
    pass

  def process(self):
    '''Load data'''
    try:
        GDA_df = pd.read_csv(self.raw_paths[0])
    except FileNotFoundError:
        raise FileNotFoundError(f"{self.raw_paths[0]} not found. Ensure the file is in the correct directory.")
    except pd.errors.EmptyDataError:
        raise ValueError(f"{self.raw_paths[0]} is empty or not formatted correctly.")

    node_features = self._construct_node_features(GDA_df)

    edge_index = torch.tensor(np.array([GDA_df['geneID'].values, GDA_df['diseaseID'].values]), dtype=torch.long)
    edge_attr = torch.tensor(GDA_df['score'].values, dtype=torch.float).view(-1, 1)

    data = tg.data.Data(
        x=node_features,
        edge_index=edge_index,
        edge_attr=edge_attr
    )
    link_split = tg.transforms.RandomLinkSplit(
        is_undirected=True,
        add_negative_train_samples=True,
        split_labels=False,
        num_val=0.1,
        num_test=0.1,
        neg_sampling_ratio=1.0,
    )
    train_data, val_data, test_data = link_split(data)

    # Save processed data for use in get method
    torch.save((train_data, val_data, test_data), self.processed_paths[0])
  def get(self, idx):
    data = torch.load(self.processed_paths[0])
    return data

  def len(self):
    return 1

  def _construct_node_features(self, GDA_df):
    '''Preprocess and construct node features for genes and diseases'''
    # Extract unique rows for genes and diseases
    gene_rows = GDA_df[['geneID', 'geneDSI', 'geneDPI'] + [col for col in GDA_df.columns if col.startswith('geneType')]]
    gene_rows = gene_rows.drop_duplicates(subset=['geneID']).drop(columns=['geneID'])

    disease_rows = GDA_df[['diseaseID'] + [col for col in GDA_df.columns if col.startswith('diseaseClass')]]
    disease_rows = disease_rows.drop_duplicates(subset=['diseaseID']).drop(columns=['diseaseID'])

    # Fill missing columns with zeros where needed
    gene_rows = gene_rows.assign(**{col: 0 for col in disease_rows.columns if col not in gene_rows.columns})
    disease_rows = disease_rows.assign(**{col: 0 for col in gene_rows.columns if col not in disease_rows.columns})

    # Convert features to numpy arrays and add node type indicator
    gene_features = np.hstack([gene_rows.values, np.ones((gene_rows.shape[0], 1))])
    disease_features = np.hstack([disease_rows.values, np.zeros((disease_rows.shape[0], 1))])

    # Combine gene and disease features into a single matrix and return as tensor
    node_features = np.vstack([gene_features, disease_features])
    return torch.tensor(node_features, dtype=torch.float)

class GDADataModule(pl.LightningDataModule):
  def __init__(self, data_dir, batch_size=32, num_workers=2):
    super(GDADataModule, self).__init__()
    self.data_dir = data_dir
    self.batch_size = batch_size
    self.num_workers = num_workers

  def setup(self, stage=None):
    dataset = GDADataset(self.data_dir)
    self.train_data, self.val_data, self.test_data = dataset[0]

  def train_dataloader(self):
    return tg.loader.DataLoader([self.train_data], batch_size=1, shuffle=False, num_workers=self.num_workers)

  def val_dataloader(self):
    return tg.loader.DataLoader([self.val_data], batch_size=1, shuffle=False, num_workers=self.num_workers)

  def test_dataloader(self):
    return tg.loader.DataLoader([self.test_data], batch_size=1, shuffle=False, num_workers=self.num_workers)